#ifndef CUHASH_TYPES_HPP
#define CUHASH_TYPES_HPP

#include <cstdint>

// Forward declarations for Montgomery and DefaultArith classes
namespace cupqc_common {
    constexpr uint32_t BabyBearPrime = 2013265921;
    constexpr uint32_t KoalaBearPrime = 2130706433;
    template<uint32_t Prime>
    class Montgomery;

    template<uint32_t Prime>
    class DefaultArith;

    using BabyBearMont    = Montgomery<BabyBearPrime>;
    using BabyBearDefault = DefaultArith<BabyBearPrime>;

    using KoalaBearMont    = Montgomery<KoalaBearPrime>;
    using KoalaBearDefault = DefaultArith<KoalaBearPrime>;
} // namespace cupqc_common

namespace cupqc {
    
    template<uint32_t N>
    __host__ __device__ constexpr uint32_t log2() {
        return 1 + log2<(N>>1)>();
    }

    template<>
    __host__ __device__ constexpr uint32_t log2<1>() {
        return 0;
    }

    template<uint32_t N, uint32_t M>
    __host__ __device__ constexpr uint32_t shift() {
        if constexpr (M <= log2<N>()) {
            return N / (1 << M ) + shift<N, M - 1>();
        }
        else {
            return 0;
        }
    }

    template<uint32_t N>
    __host__ __device__ constexpr uint32_t shift<N, 0>() {
        return N;
    }

    /* This is an object for storing a proof of a leaf in a merkle tree.
       The proof is a list of leaves that can be used to verify the leaf.
       The proof is generated by the generate_proof function.
       The proof is verified by the verify_proof function.
       Log2(N) leaves are stored in the proof, this is at most 21 for the current implementation.
    */
    template<uint32_t N, class Hash, typename Precision>
    class proof {
        public:
            static constexpr uint32_t size = log2<N>();
            static constexpr uint32_t digest_size = (Hash::has_digest_size) ? Hash::digest_size : (Hash::has_security_category) ? ((Hash::SecurityCategory == 1) ? 
                                                    256 / (8 * sizeof(Precision)) : 512 / (8 * sizeof(Precision))) : 256 / (8 * sizeof(Precision));
            Precision *nodes;
            uint32_t *indices;
            __host__ __device__ proof() {}
            __host__ __device__ ~proof() {}
            __host__ void allocate_proof() {
                cudaMalloc((void**)&this->nodes, size * digest_size * sizeof(Precision));
                cudaMalloc((void**)&this->indices, size * sizeof(uint32_t));
            }
            __host__ void free_proof() {
                cudaFree(this->nodes);
                cudaFree(this->indices);
            }
    };

    /* This is an object for storing a Merkle tree with N hashes at the first level. 
       This will contain 2*N - 1 nodes in total.
       The first N nodes are the leaves, the next N-2 nodes are the internal nodes, and the last node is the root.
       The root is composite hash of all the intermediate nodes.
       The internal nodes are the hashes of the two children.
       The leaves are the hashes of the input data.
    */
    template<uint32_t N, class Hash, typename Precision>
    class tree {
        public:
            static constexpr uint32_t size = 2 * N - 1; // Could be up to 2^22 - 1 for the current implementation
            static constexpr uint32_t digest_size = (Hash::has_digest_size) ? Hash::digest_size : (Hash::has_security_category) ? ((Hash::SecurityCategory == 1) ? 
                                                    256 / (8 * sizeof(Precision)) : 512 / (8 * sizeof(Precision))) : 256 / (8 * sizeof(Precision));
            Precision* nodes; // This is the plain data pointer for the elements of the tree. It is usually in global memory.
            __host__ __device__ tree() {}
            __host__ __device__ ~tree() {}
            __host__  void allocate_tree() {
                cudaMalloc((void**)&this->nodes, size * digest_size * sizeof(Precision));
            }
            //Note that the root is not set until after generate_tree is called.
            __device__ Precision* root() {
                return this->nodes + (size - 1) * digest_size;
            }
            __host__ void free_tree() {
                cudaFree(this->nodes);
            }
    };
}

#endif // CUHASH_TYPES_HPP
